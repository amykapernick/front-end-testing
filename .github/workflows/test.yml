# Name of the Workflow
name: Build and Test

# How the workflow is triggered, in this case every time a pull request to the prod branch gets opened, reopened or the code in the PR gets updated
# https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows
on:
  pull_request:
    types: [opened, reopened, synchronize]
    branches: [prod]

# The jobs/tasks that the workflow completes, by default these will all run at the same time
# https://docs.github.com/en/actions/using-jobs/using-jobs-in-a-workflow
jobs:
  # Each job gets a different name, eg. `build`, but the name must be unique
  build:
    # Set the platform that the job will run on, you can choose a number of different options, but running on Linux is the cheapest option
    # https://docs.github.com/en/actions/using-jobs/choosing-the-runner-for-a-job
    runs-on: ubuntu-22.04
    # Each job has a number of steps to complete (these will complete one after another), most of the time your first step will be to checkout the repo code, otherwise you won't have anything to work with
    steps:
      # Name of the action (this is for us to identify it when it runs)
      - name: Checkout Repo Code
        # The GitHub Action package that we're using in this step, most of the time this is how we'll be defining what a step does
        uses: actions/checkout@v3

      - name: Setup Node
        uses: actions/setup-node@v3
        # Some actions will also require values/config to be passed in, so these are set under the `with` property
        with:
          # Eg. for the setup node package, it can take a value of which node version you want to use
          # https://github.com/actions/setup-node#supported-version-syntax
          node-version: 20

      - name: Install Node Modules
        # We don't need a actions package to install node modules, instead we can run a command directly in the runner and install them the same way we would in our terminal
        run: npm install
